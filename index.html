<!--
index.html — Bài Cào Nêm (Firebase Realtime) — Single file
Run instructions:
1. Save this file as index.html.
2. Open it in a browser (or host on Vercel/Netlify). It will connect to Firebase Realtime DB.
3. Use "Create Room" (host) or "Join Room" with same room code. Max 10 players.
4. Host presses "Start Game" → game flow begins.

Notes:
- Firebase config already embedded (from the screenshot you provided).
- This implementation follows your requested swap mechanic:
  * All players reveal their 3 cards initially.
  * Swap happens per-card: a player chooses one of their cards and "offers" it to the offer pool.
  * After offering phase is locked (host or auto when everyone finished), players take turns picking any offered card. They may pick back their own offered card as well.
  * Each pick performs a direct swap: the taker replaces the chosen slot in their hand (or choose a slot), and the offerer receives the taker's previously-offered card (or the taker's chosen slot card) — implemented as swapping the selected slot and the offered card.
- This file uses Firebase Realtime Database in "test mode". It's not secure. Good for quick casual play.

Uploaded image reference (for your records):
/mnt/data/d3e0acc4-405b-4c8b-a9d9-eaaf4d6b59fd.png
-->

<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bài Cào Nêm — Play (Firebase Realtime)</title>
<style>
  :root{
    --bg:#071122; --card:#fff; --panel:#0b1622; --accent:#ff6b6b; --muted:#9fb3c8;
  }
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#04111a 0%, #071522 100%);color:#e8f2fb}
  .container{max-width:1100px;margin:18px auto;padding:18px;}
  header{display:flex;align-items:center;gap:12px}
  h1{font-size:20px;margin:0}
  .top-controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .panel{background:linear-gradient(180deg,#081827,#081a22);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);}
  input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .flex{display:flex;gap:12px;align-items:center}
  #playersGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;margin-top:12px}
  .playerCard{background:linear-gradient(180deg,#06202b,#07212b);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:120px;position:relative}
  .name{font-weight:700}
  .small{font-size:12px;color:var(--muted);margin-top:4px}
  .cards{display:flex;gap:8px;margin-top:10px}
  .card{width:56px;height:80px;border-radius:8px;background:var(--card);color:#000;display:flex;align-items:center;justify-content:center;font-weight:700;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .card.mask{background:linear-gradient(90deg,#0f2a3a,#043b2f);color:#fff}
  .btn{cursor:pointer}
  .log{height:120px;overflow:auto;background:#03151b;padding:8px;border-radius:8px;margin-top:12px;border:1px solid rgba(255,255,255,0.02)}
  .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .highlight{outline:3px solid rgba(132,204,22,0.12);box-shadow:0 8px 28px rgba(132,204,22,0.06)}
  .offer-badge{position:absolute;top:8px;right:8px;background:#ffd166;color:#000;padding:4px 6px;border-radius:6px;font-weight:700;font-size:12px}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,6,23,0.6)}
  .modal-box{background:linear-gradient(180deg,#08222b,#04202a);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);width:90%;max-width:640px}
  .offers-grid{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .offer-card{background:#fff;padding:8px;border-radius:8px;min-width:90px;text-align:center}
  .loser{background:#3b0f11}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .accent{color:var(--accent);font-weight:700}
  .chip{background:#062b38;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-size:13px}
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Bài Cào Nêm — Play (Realtime)</h1>
        <div class="small">Swap per-card pool — everyone reveals then offer & pick cards as group</div>
      </div>

      <div class="top-controls">
        <input id="displayName" placeholder="Tên của bạn" value="Player" />
        <input id="roomInput" placeholder="Room ID (6 ký tự)" style="width:120px" />
        <button id="createBtn" class="btn">Create Room</button>
        <button id="joinBtn" class="btn">Join Room</button>
        <div class="chip" id="roomLabel">Not in room</div>
      </div>
    </header>

    <section style="margin-top:12px" class="panel">
      <div class="flex">
        <div style="flex:1">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="startBtn" class="btn">Start Game (host)</button>
            <button id="offerDoneBtn" class="btn">I'm done offering</button>
            <button id="lockOffersBtn" class="btn">Lock Offers (host)</button>
            <button id="nextPickBtn" class="btn">Next Pick (host)</button>
            <button id="endSwapAutoBtn" class="btn">Auto End Swap Check</button>
            <div style="margin-left:12px" class="small">Mode: <span class="accent">per-card offers</span></div>
          </div>

          <div class="log" id="log"></div>
        </div>

        <div style="width:320px">
          <div class="small">Game state</div>
          <div style="margin-top:8px">
            <div><strong>State:</strong> <span id="stateLabel">LOBBY</span></div>
            <div><strong>Turn:</strong> <span id="turnLabel">-</span></div>
            <div style="margin-top:8px"><strong>Offers:</strong> <span id="offersCount">0</span></div>
            <div style="margin-top:8px"><strong>Swap history:</strong></div>
            <div id="swapHistory" class="small" style="max-height:120px;overflow:auto"></div>
          </div>
        </div>
      </div>
    </section>

    <section style="margin-top:12px" class="panel">
      <div id="playersGrid"></div>
    </section>

    <div id="modalRoot"></div>

    <footer>Created for quick play — Firebase Realtime in test mode. Not secure. Max 10 players.</footer>
  </div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
  // ====== CONFIG - from your uploaded screenshot ======
  const firebaseConfig = {
    apiKey: "AIzaSyAFYIWk3G5BzXS9pbnxy5JsQGv7OVK0DiQ",
    authDomain: "caonem-5c040.firebaseapp.com",
    databaseURL: "https://caonem-5c040-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "caonem-5c040",
    storageBucket: "caonem-5c040.appspot.com",
    messagingSenderId: "1097973722396",
    appId: "1:1097973722396:web:bb0b017146a7d974e31ed9",
    measurementId: "G-EQTSX7902Z"
  };
  // ==================================================

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Utility: deck and scoring
  const SUITS = ['♠','♥','♦','♣'];
  const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  function buildDeck(){
    const d=[];
    for(const r of RANKS) for(const s of SUITS) d.push(r+s);
    return d;
  }
  function shuffle(deck){
    for(let i=deck.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [deck[i],deck[j]]=[deck[j],deck[i]];
    }
  }
  function cardValue(rank){
    if(rank==='A') return 1;
    if(['J','Q','K'].includes(rank)) return 10;
    return parseInt(rank,10);
  }
  function scoreOfHand(cards){
    const total = cards.reduce((s,c)=> {
      const r = c.slice(0, c.length - (c.length>2?1:1)); // '10♠' -> '10'
      // but our strings are like "10♠" or "A♠", so rank is c.slice(0,-1)
      const rank = c.slice(0, -1);
      return s + cardValue(rank);
    },0);
    return total % 10;
  }

  // Room state management helpers
  function roomRef(rid){ return db.ref('rooms/' + rid); }
  function playersRef(rid){ return db.ref('rooms/' + rid + '/players'); }
  function handsRef(rid){ return db.ref('rooms/' + rid + '/hands'); }
  function offersRef(rid){ return db.ref('rooms/' + rid + '/offers'); }
  function metaRef(rid){ return db.ref('rooms/' + rid + '/meta'); }
  function swapHistoryRef(rid){ return db.ref('rooms/' + rid + '/swapHistory'); }

  // Local client state
  let local = {
    roomId: null,
    name: 'Player',
    myId: null,
    stateSnapshot: null,
    myHand: [],
    amHost: false
  };

  // UI elements
  const logEl = document.getElementById('log');
  const playersGrid = document.getElementById('playersGrid');
  const roomLabel = document.getElementById('roomLabel');
  const stateLabel = document.getElementById('stateLabel');
  const turnLabel = document.getElementById('turnLabel');
  const offersCount = document.getElementById('offersCount');
  const swapHistoryEl = document.getElementById('swapHistory');

  function log(msg){
    const d = new Date().toLocaleTimeString();
    logEl.innerHTML += `<div>[${d}] ${escapeHtml(msg)}</div>`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Create Room
  document.getElementById('createBtn').addEventListener('click', async ()=>{
    const rid = (Math.random().toString(36).slice(2,8)).toUpperCase();
    await joinRoomAsHost(rid);
  });

  // Join Room
  document.getElementById('joinBtn').addEventListener('click', async ()=>{
    const rid = document.getElementById('roomInput').value.trim().toUpperCase();
    if(!rid){ alert('Nhập mã phòng'); return; }
    await joinRoom(rid);
  });

  async function joinRoomAsHost(rid){
    local.name = document.getElementById('displayName').value || 'Host';
    local.myId = 'p_' + Math.random().toString(36).slice(2,8);
    local.roomId = rid;
    local.amHost = true;
    roomLabel.innerText = rid;
    // create room skeleton
    await roomRef(rid).set({
      meta: {state:'LOBBY', hostId: local.myId, createdAt: Date.now()},
      players: {[local.myId]: {id: local.myId, name: local.name}},
      hands: {},
      offers: {},
      swapHistory: {}
    });
    attachRoomListeners(rid);
    log('Created room ' + rid + ' as host.');
  }

  async function joinRoom(rid){
    local.name = document.getElementById('displayName').value || 'Player';
    local.myId = 'p_' + Math.random().toString(36).slice(2,8);
    local.roomId = rid;
    local.amHost = false;
    roomLabel.innerText = rid;
    // push to players list
    const pRef = playersRef(rid + '/' + local.myId);
    await pRef.set({id: local.myId, name: local.name});
    attachRoomListeners(rid);
    log('Joined room ' + rid);
  }

  function attachRoomListeners(rid){
    // detach old listeners if any
    if(local.roomListener) local.roomListener.off();
    local.roomListener = roomRef(rid);
    local.roomListener.on('value', (snap)=>{
      const val = snap.val();
      local.stateSnapshot = val;
      renderState();
    });
  }

  // Host starts game: shuffle & deal
  document.getElementById('startBtn').addEventListener('click', async ()=>{
    if(!local.roomId) return alert('Chưa vào phòng');
    if(!local.amHost) return alert('Chỉ host được start');
    const rid = local.roomId;
    // fetch players once
    const roomSnap = await roomRef(rid).get();
    const room = roomSnap.val();
    if(!room || !room.players) return alert('Room empty');
    const playerIds = Object.keys(room.players);
    if(playerIds.length < 2) return alert('Cần ít nhất 2 người');
    // build deck & deal
    const deck = buildDeck();
    shuffle(deck);
    const hands = {};
    for(const pid of playerIds){
      hands[pid] = [deck.pop(), deck.pop(), deck.pop()];
    }
    // set hands & meta
    await roomRef(rid + '/hands').set(hands);
    await metaRef(rid).set({state:'OFFER_PHASE', hostId: local.myId, turnOrder: playerIds, turnIndex: 0, offersLocked: false});
    await offersRef(rid).set(null); // clear offers
    await swapHistoryRef(rid).set(null);
    log('Game started; cards dealt and revealed. OFFER_PHASE begins.');
  });

  // Player offers a card: choose slot index 0-2
  // UI will call offerCard(slotIndex)
  async function offerCard(slotIndex){
    if(!local.roomId) return;
    const rid = local.roomId;
    const metaSnap = await metaRef(rid).get();
    const meta = metaSnap.val();
    if(!meta || meta.state !== 'OFFER_PHASE') return alert('Không trong giai đoạn offer');
    // read current hand
    const handSnap = await handsRef(rid + '/' + local.myId).get();
    const hand = handSnap.val();
    if(!hand || !hand[slotIndex]) return alert('Slot trống');
    const offerObj = {from: local.myId, slot: slotIndex, card: hand[slotIndex], ts: Date.now()};
    // push to offers path using push()
    await offersRef(rid).push(offerObj);
    // mark locally that this slot is offered by writing an offeredSlots map under players
    const offeredSlotsRef = db.ref('rooms/' + rid + '/offeredSlots/' + local.myId + '/' + slotIndex);
    await offeredSlotsRef.set(true);
    log(`${local.name} offered card in slot ${slotIndex+1}: ${offerObj.card}`);
  }

  // Player marks done offering
  document.getElementById('offerDoneBtn').addEventListener('click', async ()=>{
    if(!local.roomId) return;
    const rid = local.roomId;
    await db.ref('rooms/' + rid + '/offerDone/' + local.myId).set(true);
    log('I marked done offering.');
  });

  // Host locks offers to start pick phase
  document.getElementById('lockOffersBtn').addEventListener('click', async ()=>{
    if(!local.amHost) return alert('Chỉ host có quyền');
    if(!local.roomId) return;
    const rid = local.roomId;
    await metaRef(rid).child('offersLocked').set(true);
    await metaRef(rid).child('state').set('PICK_PHASE');
    log('Host locked offers. PICK_PHASE begins.');
    // reset turnIndex to 0 (start picks in turn order)
    const metaSnap = await metaRef(rid).get();
    const meta = metaSnap.val();
    if(meta && meta.turnOrder) await metaRef(rid).child('turnIndex').set(0);
  });

  // Host can advance to next pick (if needed)
  document.getElementById('nextPickBtn').addEventListener('click', async ()=>{
    if(!local.amHost) return alert('Chỉ host');
    const rid = local.roomId;
    const metaSnap = await metaRef(rid).get();
    const meta = metaSnap.val();
    if(!meta || !meta.turnOrder) return;
    const next = (meta.turnIndex + 1) % meta.turnOrder.length;
    await metaRef(rid).child('turnIndex').set(next);
    log('Advanced pick turn to ' + meta.turnOrder[next]);
  });

  // Auto end swap check (optional)
  document.getElementById('endSwapAutoBtn').addEventListener('click', async ()=>{
    if(!local.roomId) return;
    const rid = local.roomId;
    const metaSnap = await metaRef(rid).get();
    const meta = metaSnap.val();
    if(meta && meta.state === 'PICK_PHASE'){
      // If no offers left -> go to SHOWDOWN
      const offersSnap = await offersRef(rid).get();
      if(!offersSnap.exists()){
        await metaRef(rid).child('state').set('SHOWDOWN');
        log('No offers left. Moving to SHOWDOWN.');
        revealAndCompute();
      } else log('Offers exist. Not ending.');
    } else {
      log('Not in pick phase.');
    }
  });

  // Picking an offer: pickOffer(offerKey, targetSlotIndex)
  async function pickOffer(offerKey, targetSlotIndex){
    if(!local.roomId) return;
    const rid = local.roomId;
    const metaSnap = await metaRef(rid).get();
    const meta = metaSnap.val();
    if(!meta || meta.state !== 'PICK_PHASE') return alert('Không trong PICK_PHASE');
    // check turn
    const turnOrder = meta.turnOrder || [];
    const currentPid = turnOrder ? turnOrder[meta.turnIndex] : null;
    if(currentPid !== local.myId) return alert('Chưa tới lượt bạn pick');
    // perform transactional swap:
    const offerRef = db.ref('rooms/' + rid + '/offers/' + offerKey);
    await offerRef.transaction((currentOffer) => {
      if(currentOffer === null) return; // already taken
      // mark as taken by writing a taker field (we will finalize below)
      currentOffer.takenBy = local.myId;
      currentOffer.takenAt = Date.now();
      return currentOffer;
    }, async (err, committed, snapshot) => {
      if(err) { alert('Transaction error'); return; }
      if(!committed) { alert('Offer already taken'); return; }
      const offer = snapshot.val();
      // Now we execute swap of cards between offer.from(slot) and taker's chosen slot
      // We'll read both hands and swap values
      const handPathA = 'rooms/' + rid + '/hands/' + offer.from + '/' + offer.slot;
      const handPathB = 'rooms/' + rid + '/hands/' + local.myId + '/' + targetSlotIndex;
      // read both
      const [snapA, snapB] = await Promise.all([ db.ref(handPathA).get(), db.ref(handPathB).get() ]);
      const Acard = snapA.val();
      const Bcard = snapB.val();
      if(!Acard || !Bcard){
        alert('Slot invalid for swap');
        // revert: remove takenBy and restore by deleting offer
        await db.ref('rooms/' + rid + '/offers/' + offerKey).remove();
        return;
      }
      // write swapped values
      const updates = {};
      updates[handPathA] = Bcard;
      updates[handPathB] = Acard;
      // also remove offeredSlots map entry
      updates['rooms/' + rid + '/offeredSlots/' + offer.from + '/' + offer.slot] = null;
      updates['rooms/' + rid + '/offers/' + offerKey] = null; // remove offer
      // append swap history
      const histRef = db.ref('rooms/' + rid + '/swapHistory').push();
      updates[histRef.path.toString().replace(/^\/|^\//, '')] = {from: offer.from, to: local.myId, fromSlot: offer.slot, toSlot: targetSlotIndex, ts: Date.now()};
      await db.ref().update(updates);
      log(`${local.name} picked offer from ${offer.from} (card ${Acard}) and swapped with my slot ${targetSlotIndex+1} (${Bcard}).`);
      // advance turn
      const metaRefLocal = metaRef(rid);
      await metaRefLocal.transaction((m) => {
        if(!m) return m;
        m.turnIndex = (m.turnIndex + 1) % (m.turnOrder ? m.turnOrder.length : 1);
        return m;
      });
    });
  }

  // Reveal & compute showdown
  async function revealAndCompute(){
    if(!local.roomId) return;
    const rid = local.roomId;
    const handsSnap = await handsRef(rid).get();
    const hands = handsSnap.val() || {};
    const playersSnap = await playersRef(rid).get();
    const players = playersSnap.val() || {};
    const results = [];
    for(const pid in players){
      const hand = (hands[pid] && hands[pid].slice()) || [null,null,null];
      const score = hand.every(Boolean) ? scoreOfHand(hand) : null;
      results.push({id: pid, name: players[pid].name, hand, score});
    }
    // determine minimum (lowest) non-null score
    const validResults = results.filter(r=>r.score !== null);
    let minScore = Infinity;
    for(const r of validResults) if(r.score < minScore) minScore = r.score;
    const losers = validResults.filter(r=>r.score === minScore).map(r=>r.id);
    // write meta state
    await metaRef(rid).child('state').set('SHOWDOWN');
    await metaRef(rid).child('showdown').set({results, losers});
    // display modal locally (all clients will see same data via listener)
    log('SHOWDOWN: scores computed.');
  }

  // listen snapshot render
  function renderState(){
    const snap = local.stateSnapshot || {};
    const meta = (snap.meta) || {};
    const players = (snap.players) || {};
    const hands = (snap.hands) || {};
    const offers = (snap.offers) || {};
    const swapHistory = (snap.swapHistory) || {};
    // state labels
    const state = meta.state || 'LOBBY';
    stateLabel.innerText = state;
    // turn label
    let turnDesc = '-';
    if(meta && meta.turnOrder && typeof meta.turnIndex === 'number'){
      const pid = meta.turnOrder[meta.turnIndex];
      turnDesc = (snap.players && snap.players[pid]) ? snap.players[pid].name : pid;
    }
    turnLabel.innerText = turnDesc;
    // offers count
    offersCount.innerText = (offers ? Object.keys(offers).length : 0);
    // swap history
    swapHistoryEl.innerHTML = '';
    if(swapHistory) {
      const keys = Object.keys(swapHistory).slice(-20);
      for(const k of keys){
        const e = swapHistory[k];
        swapHistoryEl.innerHTML += `<div class="small">${e.from}→${e.to} (${e.fromSlot+1}-${e.toSlot+1})</div>`;
      }
    }
    // render players grid
    playersGrid.innerHTML = '';
    const pIds = Object.keys(players || {});
    for(const pid of pIds){
      const p = players[pid];
      const cardArray = hands[pid] || [null,null,null];
      const pc = document.createElement('div');
      pc.className = 'playerCard panel';
      if(pid === local.myId) pc.classList.add('highlight');
      let html = `<div class="name">${escapeHtml(p.name)}</div>`;
      html += `<div class="small">id: ${pid}</div>`;
      html += `<div class="cards">`;
      for(let i=0;i<3;i++){
        const c = cardArray[i];
        // check if this slot is currently offered
        const offered = (snap.offeredSlots && snap.offeredSlots[pid] && snap.offeredSlots[pid][i]) ? true : false;
        html += `<div class="card ${offered? 'mask':''}" data-slot="${i}" data-pid="${pid}">${c? escapeHtml(c) : ''}</div>`;
      }
      html += `</div>`;
      // show if this player has offered cards
      if(snap.offeredSlots && snap.offeredSlots[pid]){
        const offeredCount = Object.keys(snap.offeredSlots[pid]||{}).length;
        if(offeredCount>0) html += `<div class="offer-badge">${offeredCount} offered</div>`;
      }
      pc.innerHTML = html;
      // if this is my card area, attach click handlers to offer
      if(pid === local.myId && meta.state === 'OFFER_PHASE'){
        pc.querySelectorAll('.card').forEach(el=>{
          el.style.cursor = 'pointer';
          el.onclick = async ()=> {
            const idx = parseInt(el.getAttribute('data-slot'));
            // confirm offer
            if(confirm('Offer this card (slot '+(idx+1)+')?')) await offerCard(idx);
          };
        });
      }
      // if pick phase and offers exist, make offers selectable from modal (below)
      playersGrid.appendChild(pc);
    }

    // If showdown data exists -> show modal
    if(meta.showdown){
      showShowdownModal(meta.showdown);
    }

    // Render offers area as small section in header: clickable to pick
    renderOffersPanel(snap);
  }

  // Render offers panel (small overlay modal to pick)
  function renderOffersPanel(snap){
    // if no offers or not pick phase -> remove existing offers UI
    const offers = snap.offers || {};
    const meta = snap.meta || {};
    const modalRoot = document.getElementById('modalRoot');
    // remove previous offers modal if any
    const existing = document.getElementById('offersModal');
    if(existing) existing.remove();
    if(Object.keys(offers).length === 0) return;
    if(meta.state !== 'PICK_PHASE') return; // only show while picking
    // Build offers modal with clickable offers; each offer entry has a key
    const modal = document.createElement('div');
    modal.id = 'offersModal';
    modal.className = 'modal';
    const box = document.createElement('div');
    box.className = 'modal-box';
    let html = `<h3>Available Offers</h3><div class="offers-grid">`;
    for(const k of Object.keys(offers)){
      const of = offers[k];
      // if already taken skip
      if(of.takenBy) continue;
      html += `<div class="offer-card" data-key="${k}"><div><strong>From:</strong> ${escapeHtml(of.from)}</div><div class="small">slot ${of.slot+1}</div><div style="margin-top:6px" class="card">${escapeHtml(of.card)}</div><div style="margin-top:6px"><button class="pickBtn" data-key="${k}">Pick</button></div></div>`;
    }
    html += `</div><div style="margin-top:10px"><button id="closeOffers">Close</button></div>`;
    box.innerHTML = html;
    modal.appendChild(box);
    modalRoot.appendChild(modal);
    document.getElementById('closeOffers').onclick = ()=> modal.remove();
    // attach pick handlers (for current player's turn only)
    box.querySelectorAll('.pickBtn').forEach(b=>{
      b.onclick = async (e)=>{
        const key = b.getAttribute('data-key');
        // ask which slot to replace in my hand
        const slot = parseInt(prompt('Which slot in your hand to swap into? (1-3)', '1')) - 1;
        if(isNaN(slot) || slot < 0 || slot > 2) return alert('Invalid slot');
        await pickOffer(key, slot);
        // close modal after pick (host will advance turn)
        modal.remove();
      };
    });
  }

  // Show showdown modal
  function showShowdownModal(showdown){
    const root = document.getElementById('modalRoot');
    // remove previous
    const prev = document.getElementById('showdownModal');
    if(prev) prev.remove();
    const modal = document.createElement('div');
    modal.id = 'showdownModal';
    modal.className = 'modal';
    const box = document.createElement('div');
    box.className = 'modal-box';
    let html = `<h3>SHOWDOWN</h3><div>`;
    for(const r of showdown.results){
      const isLoser = showdown.losers.includes(r.id);
      html += `<div style="padding:8px;border-radius:8px;margin-bottom:6px;background:${isLoser? '#5b1011':'#07222a'}">`;
      html += `<div style="font-weight:700">${escapeHtml(r.name)} ${isLoser? '(LOSER)':''}</div>`;
      html += `<div class="small">Hand: ${r.hand.map(c=>c||'--').join(' | ')} — score: ${r.score}</div>`;
      html += `</div>`;
    }
    html += `</div><div style="margin-top:12px"><button id="closeShow">Close</button> <button id="playAgainBtn">Play Again (Host)</button></div>`;
    box.innerHTML = html;
    modal.appendChild(box);
    root.appendChild(modal);
    document.getElementById('closeShow').onclick = ()=> modal.remove();
    document.getElementById('playAgainBtn').onclick = async ()=>{
      if(!local.amHost) return alert('Chỉ host');
      // reset hands/offers and start a new round with the same players
      const rid = local.roomId;
      const players = Object.keys(local.stateSnapshot.players || {});
      const deck = buildDeck();
      shuffle(deck);
      const hands={};
      for(const pid of players) hands[pid] = [deck.pop(),deck.pop(),deck.pop()];
      await roomRef(rid + '/hands').set(hands);
      await metaRef(rid).update({state:'OFFER_PHASE', offersLocked:false, turnOrder: players, turnIndex: 0, showdown: null});
      await offersRef(rid).set(null);
      await db.ref('rooms/' + rid + '/offeredSlots').set(null);
      await swapHistoryRef(rid).set(null);
      modal.remove();
      log('New round started by host.');
    };
  }

  // safety: when page unloads, remove self from players list to avoid stale players
  window.addEventListener('beforeunload', async ()=>{
    if(local.roomId && local.myId){
      await db.ref('rooms/' + local.roomId + '/players/' + local.myId).remove().catch(()=>{});
    }
  });

  // initial UI
  log('Ready. Enter name & create or join a room.');

  </script>
</body>
</html>







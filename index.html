<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Swap Game</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #2c3e50; color: white; text-align: center; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #e67e22; border: none; color: white; border-radius: 5px; margin: 5px; }
        button:disabled { background: #95a5a6; cursor: not-allowed; }
        input { padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc; }
        .card { width: 60px; height: 90px; background: white; color: black; display: inline-flex; align-items: center; justify-content: center; margin: 5px; border-radius: 8px; font-weight: bold; cursor: pointer; border: 3px solid transparent; position: relative; }
        .card.selected { border-color: #e74c3c; transform: translateY(-10px); }
        .card.pool-card { background: #3498db; color: white; }
        .card.pool-selected { border-color: #f1c40f; box-shadow: 0 0 10px #f1c40f; }
        .game-area { margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; }
        .status-log { margin-bottom: 10px; font-style: italic; color: #f1c40f; }
        .player-box { border: 1px solid #7f8c8d; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .turn-indicator { color: #2ecc71; font-weight: bold; }
    </style>
</head>
<body>
    <div id="app" class="container">
        <h1>üÉè Simple Card Swap</h1>

        <div v-if="step === 'login'">
            <input v-model="myName" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" />
            <br><br>
            <button @click="createRoom" :disabled="!myName">T·∫°o Ph√≤ng (Host)</button>
            <div style="margin: 10px;">HO·∫∂C</div>
            <input v-model="joinId" placeholder="Nh·∫≠p Room ID" />
            <button @click="joinRoom" :disabled="!myName || !joinId">V√†o Ph√≤ng</button>
            <p v-if="loading">ƒêang k·∫øt n·ªëi...</p>
        </div>

        <div v-else-if="step === 'lobby'">
            <h2>Ph√≤ng: {{ roomId }}</h2>
            <p>G·ª≠i ID n√†y cho b·∫°n b√® ƒë·ªÉ h·ªç tham gia.</p>
            <div class="player-box">
                <h3>Ng∆∞·ªùi ch∆°i trong ph√≤ng:</h3>
                <ul>
                    <li v-for="p in players" :key="p.id">{{ p.name }} {{ p.id === myId ? '(B·∫°n)' : '' }} <span v-if="p.isHost">üëë</span></li>
                </ul>
            </div>
            <button v-if="isHost" @click="startGame" :disabled="players.length < 2">B·∫Øt ƒë·∫ßu Game</button>
            <p v-else>Ch·ªù ch·ªß ph√≤ng b·∫Øt ƒë·∫ßu...</p>
        </div>

        <div v-else-if="step === 'game'">
            <div class="status-log">{{ statusMessage }}</div>

            <div class="game-area" v-if="gamePhase === 'picking'">
                <h3>Pool (B√†i chung)</h3>
                <div>
                    <div 
                        v-for="(card, index) in pool" 
                        class="card pool-card"
                        :class="{ 'pool-selected': selectedPoolIndex === index }"
                        @click="selectPoolCard(index)">
                        {{ card }}
                    </div>
                </div>
            </div>

            <div class="game-area">
                <h3>B√†i c·ªßa b·∫°n ({{ myName }})</h3>
                <div v-if="myHand.length > 0">
                    <div 
                        v-for="(card, index) in myHand" 
                        class="card" 
                        :class="{ 'selected': selectedHandIndex === index }"
                        @click="onHandCardClick(index)">
                        {{ card }}
                    </div>
                </div>
                
                <div v-if="gamePhase === 'offering'">
                    <p>Ch·ªçn 1 l√° b√†i ƒë·ªÉ Offer (G√≥p v√†o Pool)</p>
                    <button @click="confirmOffer" :disabled="selectedHandIndex === null || hasOffered">
                        {{ hasOffered ? "ƒê√£ Offer Xong" : "I'm done offering" }}
                    </button>
                </div>

                <div v-if="gamePhase === 'picking'">
                    <div v-if="isMyTurn">
                        <p class="turn-indicator">‚ö° T·ªõi l∆∞·ª£t b·∫°n! Ch·ªçn 1 l√° t·ª´ Pool v√† 1 l√° tr√™n tay ƒë·ªÉ ƒë·ªïi.</p>
                        <button @click="confirmSwap" :disabled="selectedHandIndex === null || selectedPoolIndex === null">
                            ƒê·ªïi b√†i (Swap)
                        </button>
                    </div>
                    <div v-else>
                        <p>ƒêang ƒë·ª£i l∆∞·ª£t c·ªßa: <strong>{{ currentTurnName }}</strong></p>
                    </div>
                </div>
            </div>

            <div v-if="isHost && gamePhase === 'offering'" style="margin-top: 20px; border-top: 1px solid white; padding-top:10px;">
                <h3>Host Control</h3>
                <p>ƒê√£ Offer: {{ offeredCount }} / {{ players.length }} ng∆∞·ªùi</p>
                <button @click="hostLockOffers">Lock Offers & Start Picking</button>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    step: 'login', // login, lobby, game
                    loading: false,
                    myName: '',
                    myId: '',
                    roomId: '',
                    joinId: '',
                    isHost: false,
                    peer: null,
                    conns: [], // Host l∆∞u danh s√°ch k·∫øt n·ªëi
                    hostConn: null, // Client l∆∞u k·∫øt n·ªëi t·ªõi Host
                    
                    // Game State (ƒê·ªìng b·ªô t·ª´ Host)
                    players: [], // {id, name, isHost}
                    gamePhase: 'offering', // offering, picking
                    pool: [],
                    turnIndex: 0,
                    
                    // Local State (Ri√™ng t∆∞)
                    myHand: [],
                    selectedHandIndex: null,
                    selectedPoolIndex: null,
                    hasOffered: false,
                    statusMessage: ''
                }
            },
            computed: {
                offeredCount() {
                    return this.players.filter(p => p.hasOffered).length;
                },
                isMyTurn() {
                    if (this.gamePhase !== 'picking' || this.players.length === 0) return false;
                    return this.players[this.turnIndex].id === this.myId;
                },
                currentTurnName() {
                    if (this.players.length === 0) return '';
                    return this.players[this.turnIndex].name;
                }
            },
            methods: {
                // --- SETUP K·∫æT N·ªêI ---
                initPeer(id = null) {
                    return new Promise((resolve, reject) => {
                        // T·∫°o Peer ID ng·∫´u nhi√™n ng·∫Øn g·ªçn 1 ch√∫t cho d·ªÖ test
                        const peerId = id || Math.random().toString(36).substr(2, 6).toUpperCase();
                        this.peer = new Peer(peerId);
                        
                        this.peer.on('open', (id) => {
                            this.myId = id;
                            resolve(id);
                        });

                        this.peer.on('connection', (conn) => {
                            if (this.isHost) this.handleHostConnection(conn);
                        });

                        this.peer.on('error', (err) => {
                            console.error(err);
                            alert("L·ªói k·∫øt n·ªëi: " + err.type);
                            this.loading = false;
                        });
                    });
                },

                async createRoom() {
                    this.loading = true;
                    this.isHost = true;
                    await this.initPeer();
                    this.roomId = this.myId;
                    // Th√™m ch√≠nh m√¨nh v√†o danh s√°ch
                    this.players.push({ id: this.myId, name: this.myName, isHost: true, hasOffered: false });
                    this.step = 'lobby';
                    this.loading = false;
                },

                async joinRoom() {
                    this.loading = true;
                    this.isHost = false;
                    await this.initPeer(); // Client t·ª± c√≥ ID ri√™ng
                    
                    // K·∫øt n·ªëi t·ªõi Host
                    const conn = this.peer.connect(this.joinId);
                    
                    conn.on('open', () => {
                        this.hostConn = conn;
                        this.roomId = this.joinId;
                        
                        // G·ª≠i th√¥ng tin ƒëƒÉng k√Ω
                        conn.send({ type: 'JOIN', name: this.myName });

                        // L·∫Øng nghe data t·ª´ Host
                        conn.on('data', (data) => {
                            this.handleClientData(data);
                        });
                    });

                    conn.on('error', () => { alert("Kh√¥ng t√¨m th·∫•y ph√≤ng!"); this.loading = false; });
                },

                // --- HOST LOGIC (X·ª≠ l√Ω Server) ---
                handleHostConnection(conn) {
                    this.conns.push(conn);
                    
                    conn.on('data', (data) => {
                        // X·ª≠ l√Ω c√°c h√†nh ƒë·ªông t·ª´ Client g·ª≠i l√™n
                        switch(data.type) {
                            case 'JOIN':
                                this.players.push({ id: conn.peer, name: data.name, isHost: false, hasOffered: false });
                                this.broadcastState();
                                break;
                            case 'OFFER_CARD':
                                // L∆∞u t·∫°m l√° b√†i client offer (ch∆∞a ƒë∆∞a v√†o pool ngay)
                                const pOffer = this.players.find(p => p.id === conn.peer);
                                if(pOffer) {
                                    pOffer.tempOffer = data.card;
                                    pOffer.hasOffered = true;
                                }
                                this.broadcastState();
                                break;
                            case 'SWAP_CARD':
                                if (this.players[this.turnIndex].id === conn.peer) {
                                    this.processSwap(conn.peer, data.poolIdx, data.handCard);
                                }
                                break;
                        }
                    });

                    conn.on('close', () => {
                        this.players = this.players.filter(p => p.id !== conn.peer);
                        this.broadcastState();
                    });
                },

                broadcastState() {
                    // D·ªØ li·ªáu g·ª≠i cho T·∫§T C·∫¢ (Public state)
                    const publicState = {
                        type: 'UPDATE_STATE',
                        step: this.step,
                        players: this.players.map(p => ({ id: p.id, name: p.name, isHost: p.isHost, hasOffered: p.hasOffered })),
                        gamePhase: this.gamePhase,
                        pool: this.pool,
                        turnIndex: this.turnIndex
                    };

                    // G·ª≠i cho t·ª´ng client
                    this.conns.forEach(conn => conn.send(publicState));
                    
                    // Host t·ª± c·∫≠p nh·∫≠t UI c·ªßa m√¨nh (v√¨ host kh√¥ng nh·∫≠n data qua m·∫°ng)
                    // Host logic ch·∫°y tr·ª±c ti·∫øp tr√™n bi·∫øn data c·ªßa Vue, n√™n kh√¥ng c·∫ßn l√†m g√¨ th√™m v·ªõi public data
                    // NH∆ØNG c·∫ßn c·∫≠p nh·∫≠t c√°c bi·∫øn local n·∫øu c·∫ßn. ·ªû ƒë√¢y ta d√πng chung data.
                },

                broadcastHand(playerId, hand) {
                    if (playerId === this.myId) {
                        this.myHand = hand;
                    } else {
                        const conn = this.conns.find(c => c.peer === playerId);
                        if (conn) conn.send({ type: 'YOUR_HAND', hand: hand });
                    }
                },

                startGame() {
                    // Chia b√†i
                    const deck = ['A','2','3','4','5','6','7','8','9','10','J','Q','K', 'A','2','3','4','5','6','7','8','9','10','J','Q','K']; // Deck ƒë∆°n gi·∫£n
                    
                    this.players.forEach(p => {
                        const hand = [];
                        for(let i=0; i<3; i++) {
                            const rand = Math.floor(Math.random() * deck.length);
                            hand.push(deck[rand]);
                        }
                        this.broadcastHand(p.id, hand);
                        p.hasOffered = false;
                        p.tempOffer = null;
                    });

                    this.gamePhase = 'offering';
                    this.step = 'game';
                    this.statusMessage = "M·ªçi ng∆∞·ªùi h√£y ch·ªçn 1 l√° b√†i ƒë·ªÉ Offer!";
                    this.broadcastState();
                },

                hostLockOffers() {
                    // Gom b√†i offer v√†o Pool
                    this.players.forEach(p => {
                        if(p.tempOffer) {
                            this.pool.push(p.tempOffer);
                            p.tempOffer = null; // Clear temp
                            
                            // C·∫ßn x√≥a l√° b√†i ƒë√≥ kh·ªèi tay ng∆∞·ªùi ch∆°i (Logic n√†y Host ph·∫£i qu·∫£n l√Ω ho·∫∑c tin t∆∞·ªüng Client)
                            // ƒê·ªÉ ƒë∆°n gi·∫£n: Host ƒë√£ nh·∫≠n "gi√° tr·ªã" l√° b√†i, Client t·ª± x√≥a hi·ªÉn th·ªã. 
                            // ƒê√∫ng ra Host n√™n gi·ªØ 'Server Authoritative' to√†n b·ªô Hand, nh∆∞ng ƒë·ªÉ code ng·∫Øn g·ªçn, ta x·ª≠ l√Ω b√°n tin c·∫≠y.
                        }
                    });
                    
                    this.gamePhase = 'picking';
                    this.turnIndex = 0;
                    this.statusMessage = "ƒê√£ kh√≥a Offer! B·∫Øt ƒë·∫ßu l∆∞·ª£t Pick.";
                    this.broadcastState();
                },

                processSwap(playerId, poolIdx, handCard) {
                    // Host th·ª±c hi·ªán logic ƒë·ªïi b√†i
                    const cardFromPool = this.pool[poolIdx];
                    
                    // C·∫≠p nh·∫≠t Pool: Thay l√° t·ª´ pool b·∫±ng l√° t·ª´ tay ng∆∞·ªùi ch∆°i tr·∫£ l·∫°i
                    this.pool[poolIdx] = handCard;
                    
                    // G·ª≠i l√° b√†i m·ªõi v·ªÅ cho ng∆∞·ªùi ch∆°i
                    // Ng∆∞·ªùi ch∆°i t·ª± c·∫≠p nh·∫≠t UI tay m√¨nh, Host ch·ªâ c·∫ßn confirm state
                    
                    // Chuy·ªÉn l∆∞·ª£t
                    this.turnIndex = (this.turnIndex + 1) % this.players.length;
                    this.broadcastState();

                    // G·ª≠i tin nh·∫Øn ri√™ng cho ng∆∞·ªùi ch∆°i ƒë·ªÉ h·ªç c·∫≠p nh·∫≠t Hand ch√≠nh th·ª©c (swap th√†nh c√¥ng)
                    if(playerId === this.myId) {
                        this.handleSwapSuccess(cardFromPool);
                    } else {
                        const conn = this.conns.find(c => c.peer === playerId);
                        if(conn) conn.send({ type: 'SWAP_SUCCESS', newCard: cardFromPool });
                    }
                },

                // --- CLIENT LOGIC ---
                handleClientData(data) {
                    if (data.type === 'UPDATE_STATE') {
                        this.players = data.players;
                        this.gamePhase = data.gamePhase;
                        this.pool = data.pool;
                        this.turnIndex = data.turnIndex;
                        if(data.step) this.step = data.step;
                        this.loading = false;
                    } 
                    else if (data.type === 'YOUR_HAND') {
                        this.myHand = data.hand;
                        this.hasOffered = false;
                        this.selectedHandIndex = null;
                    }
                    else if (data.type === 'SWAP_SUCCESS') {
                        this.handleSwapSuccess(data.newCard);
                    }
                },

                // --- GAMEPLAY UI ACTIONS ---
                onHandCardClick(index) {
                    this.selectedHandIndex = index;
                },
                
                selectPoolCard(index) {
                    if(this.gamePhase === 'picking' && this.isMyTurn) {
                        this.selectedPoolIndex = index;
                    }
                },

                confirmOffer() {
                    if (this.selectedHandIndex === null) return;
                    const card = this.myHand[this.selectedHandIndex];
                    
                    // G·ª≠i l√™n Host
                    if (this.isHost) {
                        const me = this.players.find(p => p.id === this.myId);
                        me.tempOffer = card;
                        me.hasOffered = true;
                        this.broadcastState();
                    } else {
                        this.hostConn.send({ type: 'OFFER_CARD', card: card });
                    }

                    // X√≥a kh·ªèi tay m√¨nh (UI)
                    this.myHand.splice(this.selectedHandIndex, 1);
                    this.hasOffered = true;
                    this.selectedHandIndex = null;
                },

                confirmSwap() {
                    const cardToGive = this.myHand[this.selectedHandIndex];
                    
                    if (this.isHost) {
                        this.processSwap(this.myId, this.selectedPoolIndex, cardToGive);
                    } else {
                        this.hostConn.send({ 
                            type: 'SWAP_CARD', 
                            poolIdx: this.selectedPoolIndex, 
                            handCard: cardToGive 
                        });
                    }
                },

                handleSwapSuccess(newCard) {
                    // Thay th·∫ø l√° b√†i tr√™n tay (l√° c≈© ƒë√£ g·ª≠i ƒëi, gi·ªù nh·∫≠n l√° m·ªõi v√†o v·ªã tr√≠ ƒë√≥)
                    this.myHand[this.selectedHandIndex] = newCard;
                    this.selectedHandIndex = null;
                    this.selectedPoolIndex = null;
                }
            }
        });
    </script>
</body>
</html>
